#include "ob1203_handler.h"
#include <stdio.h>
#include <string.h>

/* I2C instance - generated by FSP */
extern rm_comms_i2c_instance_ctrl_t g_biomet_comms_i2c_ctrl;
extern const rm_comms_cfg_t         g_biomet_comms_i2c_cfg;
extern void uart_print(char const * msg);

/* I2C sync flags */
static volatile uint8_t          g_i2c_done = 0;
static volatile rm_comms_event_t g_i2c_evt  = 0;

/* ==================== Register Map (PPG / SpO2 path only) ==================== */
#define OB1203_REG_STATUS0           (0x00u)
#define OB1203_REG_STATUS1           (0x01u)
#define OB1203_REG_MAIN_CTRL_0       (0x15u)
#define OB1203_REG_MAIN_CTRL_1       (0x16u)
#define OB1203_REG_PPG_PS_GAIN       (0x2Eu)
#define OB1203_REG_PPG_IR_LED_0      (0x30u)
#define OB1203_REG_PPG_R_LED_0       (0x32u)
#define OB1203_REG_PPG_AVG           (0x35u)
#define OB1203_REG_PPG_PWIDTH_RATE   (0x36u)
#define OB1203_REG_FIFO_CFG          (0x37u)
#define OB1203_REG_FIFO_WR_PTR       (0x38u)
#define OB1203_REG_FIFO_RD_PTR       (0x39u)
#define OB1203_REG_FIFO_DATA         (0x3Bu)
#define OB1203_REG_PART_ID           (0x3Du)
#define OB1203_REG_DIG_LED1_TRIM     (0x42u)
#define OB1203_REG_DIG_LED2_TRIM     (0x43u)

/* Bit definitions */
#define OB1203_SW_RESET              (1u << 7)

/* ==================== Low level I2C helpers ==================== */

/* Wait for a communication event or timeout */
static fsp_err_t wait_i2c (uint32_t timeout)
{
    uint32_t cnt = 0;

    while (!g_i2c_done && (cnt++ < timeout))
    {
        __NOP();
    }

    if (!g_i2c_done)
    {
        uart_print("[OB1203] I2C timeout\r\n");
        return FSP_ERR_TIMEOUT;
    }

    g_i2c_done = 0;

    if (g_i2c_evt != RM_COMMS_EVENT_OPERATION_COMPLETE)
    {
        char msg[48];
        snprintf(msg, sizeof(msg), "[OB1203] I2C error (evt=%d)\r\n", g_i2c_evt);
        uart_print(msg);
        return FSP_ERR_ABORTED;
    }

    return FSP_SUCCESS;
}

/* Write sequence: register address + payload */
static fsp_err_t reg_write (uint8_t reg, uint8_t const * p_data, uint8_t len)
{
    uint8_t buf[1 + 8];

    if (len > 8)
    {
        return FSP_ERR_ASSERTION;
    }

    buf[0] = reg;
    memcpy(&buf[1], p_data, len);

    g_i2c_done = 0;
    g_i2c_evt  = 0;

    fsp_err_t err = RM_COMMS_I2C_Write(&g_biomet_comms_i2c_ctrl, buf, (uint16_t) (len + 1));
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    return wait_i2c(1000000u);
}

/* Read sequence: write register address, then read data back */
static fsp_err_t reg_read (uint8_t reg, uint8_t * p_data, uint8_t len)
{
    fsp_err_t err;

    /* Write register address */
    g_i2c_done = 0;
    g_i2c_evt  = 0;
    err        = RM_COMMS_I2C_Write(&g_biomet_comms_i2c_ctrl, &reg, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    err = wait_i2c(1000000u);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* Read data back */
    g_i2c_done = 0;
    g_i2c_evt  = 0;
    err        = RM_COMMS_I2C_Read(&g_biomet_comms_i2c_ctrl, p_data, len);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    return wait_i2c(1000000u);
}

/* ==================== Utility helpers ==================== */

/* Software reset via control register (no hardware reset pin used) */
fsp_err_t ob1203_soft_reset (void)
{
    uint8_t val = OB1203_SW_RESET;
    return reg_write(OB1203_REG_MAIN_CTRL_0, &val, 1);
}

/* Read PART_ID register */
fsp_err_t ob1203_read_part_id (uint8_t * p_part_id)
{
    if (!p_part_id)
    {
        return FSP_ERR_ASSERTION;
    }

    return reg_read(OB1203_REG_PART_ID, p_part_id, 1);
}

/* Read status registers 0 and 1 */
fsp_err_t ob1203_read_status (uint8_t * p_status0, uint8_t * p_status1)
{
    if ((!p_status0) || (!p_status1))
    {
        return FSP_ERR_ASSERTION;
    }

    fsp_err_t err = reg_read(OB1203_REG_STATUS0, p_status0, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    return reg_read(OB1203_REG_STATUS1, p_status1, 1);
}

/* ==================== High level control ==================== */

/* Initialization:
 *  - Open I2C if needed
 *  - Delay for power up
 *  - Issue software reset
 *  - Read part ID and status (debug)
 */
fsp_err_t ob1203_init (void)
{
    static uint8_t opened = 0;
    fsp_err_t      err;
    char           msg[64];

    /* Open I2C bus for OB1203 (only once) */
    if (!opened)
    {
        err = RM_COMMS_I2C_Open(&g_biomet_comms_i2c_ctrl, &g_biomet_comms_i2c_cfg);
        if (FSP_SUCCESS != err)
        {
            uart_print("[OB1203] I2C open failed\r\n");
            return err;
        }

        opened = 1;
        uart_print("[OB1203] I2C opened\r\n");
    }

    /* Wait for device power-up.
     * OB1203 in this design has NO reset pin,
     * so we only wait and then use software reset. */
    vTaskDelay(pdMS_TO_TICKS(100));

    /* Software reset via control register */
    uart_print("[OB1203] Performing soft reset...\r\n");
    err = ob1203_soft_reset();
    if (FSP_SUCCESS != err)
    {
        uart_print("[OB1203] Soft reset failed - writing known safe defaults\r\n");

        /* Fallback: disable all blocks first */
        uint8_t val = 0x00;
        (void) reg_write(OB1203_REG_MAIN_CTRL_0, &val, 1);
        (void) reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);

        vTaskDelay(pdMS_TO_TICKS(50));
    }
    else
    {
        vTaskDelay(pdMS_TO_TICKS(50));
    }

    /* Read part ID for debug */
    uint8_t part_id = 0;
    err             = ob1203_read_part_id(&part_id);

    snprintf(msg, sizeof(msg), "[OB1203] Part ID: 0x%02X (err=%d)\r\n", part_id, err);
    uart_print(msg);

    /* Read status (optional) */
    uint8_t st0 = 0;
    uint8_t st1 = 0;
    (void) ob1203_read_status(&st0, &st1);
    snprintf(msg, sizeof(msg), "[OB1203] Status: 0x%02X 0x%02X\r\n", st0, st1);
    uart_print(msg);

    uart_print("[OB1203] Init complete\r\n");

    return FSP_SUCCESS;
}

/* Configure LED currents, gain, averaging, pulse width, sample rate and FIFO */
fsp_err_t ob1203_configure (ob1203_config_t const * p_config)
{
    if (!p_config)
    {
        return FSP_ERR_ASSERTION;
    }

    fsp_err_t err;
    uint8_t   val;
    uint8_t   buf[2];

    uart_print("[OB1203] Configuring...\r\n");

    /* 1. Disable digital trim (use default) */
    val = 0x00;
    err = reg_write(OB1203_REG_DIG_LED1_TRIM, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    err = reg_write(OB1203_REG_DIG_LED2_TRIM, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 2. Set IR LED current (ILED1) */
    uint16_t ir_curr = (uint16_t) (p_config->ir_led_current & 0x01FFu);
    buf[0]           = (uint8_t) (ir_curr & 0xFFu);
    buf[1]           = (uint8_t) ((ir_curr >> 8) & 0x01u);
    err              = reg_write(OB1203_REG_PPG_IR_LED_0, buf, 2);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 3. Set RED LED current (ILED2) */
    uint16_t red_curr = (uint16_t) (p_config->red_led_current & 0x01FFu);
    buf[0]            = (uint8_t) (red_curr & 0xFFu);
    buf[1]            = (uint8_t) ((red_curr >> 8) & 0x01u);
    err               = reg_write(OB1203_REG_PPG_R_LED_0, buf, 2);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 4. Gain configuration (fixed value compatible with original project) */
    val = 0x09u;
    err = reg_write(OB1203_REG_PPG_PS_GAIN, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 5. Averaging configuration: encoded as N-1 (0..31) */
    if ((p_config->averaging > 0u) && (p_config->averaging <= 32u))
    {
        val = (uint8_t) (p_config->averaging - 1u);
    }
    else
    {
        /* Default to 16x averaging if out of range */
        val = 0x0Fu;
    }

    err = reg_write(OB1203_REG_PPG_AVG, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 6. Pulse width and sample rate:
     *    Example: 130us pulse, 100 Hz sample rate. Adjust if needed. */
    val = 0x42u;
    err = reg_write(OB1203_REG_PPG_PWIDTH_RATE, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 7. FIFO configuration:
     *    PPG2 mode (IR+RED), FIFO rollover enabled, etc. */
    val = 0x70u;
    err = reg_write(OB1203_REG_FIFO_CFG, &val, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* 8. Reset FIFO pointers */
    val = 0x00u;
    (void) reg_write(OB1203_REG_FIFO_WR_PTR, &val, 1);
    (void) reg_write(OB1203_REG_FIFO_RD_PTR, &val, 1);

    uart_print("[OB1203] Configured\r\n");
    return FSP_SUCCESS;
}

/* Enable PPG2 measurement (SpO2 / HR) via MAIN_CTRL_1 register */
fsp_err_t ob1203_start_measurement(void)
{
    /* MAIN_CTRL_1 (0x16):
     * bit[3]   = SAI_PS      -> 0 (no sleep-after-interrupt for PS)
     * bit[2:1] = PPG_PS_MODE -> 10b = PPG2 mode (IR + RED interleaved)
     * bit[0]   = PPG_PS_EN   -> 1 = enable PPG/PS block
     *
     * => 0b0000 0101 = 0x05
     */
    uint8_t  val = 0x05;
    fsp_err_t err = reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);

    if (FSP_SUCCESS == err)
    {
        uart_print("[OB1203] PPG2 enabled (MAIN_CTRL_1=0x05)\r\n");
    }
    else
    {
        uart_print("[OB1203] Failed to enable PPG2\r\n");
    }

    return err;
}

/* Disable PPG2 measurement */
fsp_err_t ob1203_stop_measurement (void)
{
    uint8_t val = 0x00u;

    return reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);
}

/* ==================== FIFO / data path ==================== */

/* Decode one 18-bit PPG sample from 3 bytes in FIFO_DATA
 * Layout from datasheet:
 *  1st byte: LSB
 *  2nd byte: middle
 *  3rd byte: bits[1:0] = MSB (bits[17:16] of result)
 */
static uint32_t ob1203_decode_sample(const uint8_t * p_bytes)
{
    uint32_t lsb   = p_bytes[0];
    uint32_t mid   = p_bytes[1];
    uint32_t msb2  = (uint32_t)(p_bytes[2] & 0x03u);  /* only bits[1:0] */

    return (lsb | (mid << 8) | (msb2 << 16));
}

fsp_err_t ob1203_read_fifo(ob1203_data_t * p_out, uint8_t * p_samples_available)
{
    if ((NULL == p_out) || (NULL == p_samples_available))
    {
        return FSP_ERR_ASSERTION;
    }

    fsp_err_t err;
    uint8_t   wr_ptr;
    uint8_t   rd_ptr;

    /* Read FIFO write/read pointers */
    err = reg_read(OB1203_REG_FIFO_WR_PTR, &wr_ptr, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    err = reg_read(OB1203_REG_FIFO_RD_PTR, &rd_ptr, 1);
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* Pointers are 5-bit values (0..31) */
    wr_ptr &= 0x1Fu;
    rd_ptr &= 0x1Fu;

    /* Number of FIFO words currently stored (circular buffer) */
    uint8_t words =
        (wr_ptr >= rd_ptr)
        ? (uint8_t)(wr_ptr - rd_ptr)
        : (uint8_t)(32u + wr_ptr - rd_ptr);

    /* In PPG2 mode, one pair (IR, RED) uses 2 FIFO words = 6 bytes */
    *p_samples_available = (uint8_t)(words / 2u);

    /* Debug: see FIFO usage */
    {
        char msg[96];
        snprintf(msg, sizeof(msg),
                 "[OB1203] FIFO wr=%u rd=%u words=%u pairs=%u\r\n",
                 wr_ptr, rd_ptr, words, *p_samples_available);
        uart_print(msg);
    }

    /* No data available â€“ return but do not treat as error */
    if (0u == *p_samples_available)
    {
        memset(p_out, 0, sizeof(*p_out));
        p_out->valid = 0u;
        return FSP_SUCCESS;
    }

    /* Read one IR + RED pair (6 bytes) from FIFO_DATA.
     * The I2C register address stays at 0x3B, but FIFO_RD_PTR
     * is auto-incremented by the internal FIFO engine after each 3-byte sample.
     */
    uint8_t fifo_data[6];

    err = reg_read(OB1203_REG_FIFO_DATA, fifo_data, sizeof(fifo_data));
    if (FSP_SUCCESS != err)
    {
        return err;
    }

    /* First 3 bytes = IR, next 3 bytes = RED (PPG2 mode, standard LED order) */
    uint32_t ir_raw  = ob1203_decode_sample(&fifo_data[0]);
    uint32_t red_raw = ob1203_decode_sample(&fifo_data[3]);

    p_out->ir_raw  = ir_raw;
    p_out->red_raw = red_raw;
    p_out->valid   = 1u;

    /* Simple placeholder algorithm for HR / SpO2.
     * Replace this with a real PPG algorithm later.
     */
    p_out->heart_rate_bpm = 70.0f + ((float)(ir_raw  % 100u) * 0.3f);
    p_out->spo2_percent   = 96.0f + ((float)(red_raw % 50u)  * 0.05f);

    if (p_out->heart_rate_bpm > 180.0f)
    {
        p_out->heart_rate_bpm = 180.0f;
    }

    if (p_out->spo2_percent > 100.0f)
    {
        p_out->spo2_percent = 100.0f;
    }

    return FSP_SUCCESS;
}

/* High-level read: just call FIFO reader and ignore sample count */
fsp_err_t ob1203_read (ob1203_data_t * p_out)
{
    uint8_t samples = 0u;
    return ob1203_read_fifo(p_out, &samples);
}

/* ==================== I2C callback ==================== */

/* Communication callback for OB1203 Comms middleware */
void biomet_comms_i2c_callback (rm_comms_callback_args_t * p_args)
{
    if (NULL == p_args)
    {
        return;
    }

    g_i2c_evt  = p_args->event;
    g_i2c_done = 1u;
}
