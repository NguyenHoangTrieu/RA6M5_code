#include "ob1203_handler.h"
#include "ob1203_hr.h"
#include <stdio.h>
#include <string.h>
#include <math.h>

static ob1203_hr_state_t g_ob1203_hr;
static uint8_t g_ob1203_hr_initialized = 0;
static float  g_spo2_ir_dc        = 0.0f;
static float  g_spo2_red_dc       = 0.0f;
static float  g_spo2_R_filtered   = 0.0f;
static uint8_t g_spo2_initialized = 0U;
/* I2C instance - generated by FSP */
extern rm_comms_i2c_instance_ctrl_t g_biomet_comms_i2c_ctrl;
extern const rm_comms_cfg_t g_biomet_comms_i2c_cfg;
extern void uart_print(char const *msg);

/* I2C sync flags */
static volatile uint8_t g_i2c_done = 0;
static volatile rm_comms_event_t g_i2c_evt = 0;

/* ==================== Register Map (PPG / SpO2 path only) ====================
 */
#define OB1203_REG_STATUS0 (0x00u)
#define OB1203_REG_STATUS1 (0x01u)
#define OB1203_REG_MAIN_CTRL_0 (0x15u)
#define OB1203_REG_MAIN_CTRL_1 (0x16u)
#define OB1203_REG_PPG_PS_GAIN (0x2Eu)
#define OB1203_REG_PPG_IR_LED_0 (0x30u)
#define OB1203_REG_PPG_R_LED_0 (0x32u)
#define OB1203_REG_PPG_AVG (0x35u)
#define OB1203_REG_PPG_PWIDTH_RATE (0x36u)
#define OB1203_REG_FIFO_CFG (0x37u)
#define OB1203_REG_FIFO_WR_PTR (0x38u)
#define OB1203_REG_FIFO_RD_PTR (0x39u)
#define OB1203_REG_FIFO_DATA (0x3Bu)
#define OB1203_REG_PART_ID (0x3Du)
#define OB1203_REG_DIG_LED1_TRIM (0x42u)
#define OB1203_REG_DIG_LED2_TRIM (0x43u)

/* Bit definitions */
#define OB1203_SW_RESET (1u << 7)

/* ==================== Low level I2C helpers ==================== */

/* Wait for a communication event or timeout */
static fsp_err_t wait_i2c(uint32_t timeout) {
  uint32_t cnt = 0;

  while (!g_i2c_done && (cnt++ < timeout)) {
    __NOP();
  }

  if (!g_i2c_done) {
    uart_print("[OB1203] I2C timeout\r\n");
    return FSP_ERR_TIMEOUT;
  }

  g_i2c_done = 0;

  if (g_i2c_evt != RM_COMMS_EVENT_OPERATION_COMPLETE) {
    char msg[48];
    snprintf(msg, sizeof(msg), "[OB1203] I2C error (evt=%d)\r\n", g_i2c_evt);
    uart_print(msg);
    return FSP_ERR_ABORTED;
  }

  return FSP_SUCCESS;
}

/* Write sequence: register address + payload */
static fsp_err_t reg_write(uint8_t reg, uint8_t const *p_data, uint8_t len) {
  uint8_t buf[1 + 8];

  if (len > 8) {
    return FSP_ERR_ASSERTION;
  }

  buf[0] = reg;
  memcpy(&buf[1], p_data, len);

  g_i2c_done = 0;
  g_i2c_evt = 0;

  fsp_err_t err =
      RM_COMMS_I2C_Write(&g_biomet_comms_i2c_ctrl, buf, (uint16_t)(len + 1));
  if (FSP_SUCCESS != err) {
    return err;
  }

  return wait_i2c(1000000u);
}

/* Read sequence: write register address, then read data back */
static fsp_err_t reg_read(uint8_t reg, uint8_t *p_data, uint8_t len) {
  fsp_err_t err;

  /* Write register address */
  g_i2c_done = 0;
  g_i2c_evt = 0;
  err = RM_COMMS_I2C_Write(&g_biomet_comms_i2c_ctrl, &reg, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  err = wait_i2c(1000000u);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* Read data back */
  g_i2c_done = 0;
  g_i2c_evt = 0;
  err = RM_COMMS_I2C_Read(&g_biomet_comms_i2c_ctrl, p_data, len);
  if (FSP_SUCCESS != err) {
    return err;
  }

  return wait_i2c(1000000u);
}

/* ==================== Utility helpers ==================== */

/* Software reset via control register (no hardware reset pin used) */
fsp_err_t ob1203_soft_reset(void) {
  uint8_t val = OB1203_SW_RESET;
  return reg_write(OB1203_REG_MAIN_CTRL_0, &val, 1);
}

/* Read PART_ID register */
fsp_err_t ob1203_read_part_id(uint8_t *p_part_id) {
  if (!p_part_id) {
    return FSP_ERR_ASSERTION;
  }

  return reg_read(OB1203_REG_PART_ID, p_part_id, 1);
}

/* Read status registers 0 and 1 */
fsp_err_t ob1203_read_status(uint8_t *p_status0, uint8_t *p_status1) {
  if ((!p_status0) || (!p_status1)) {
    return FSP_ERR_ASSERTION;
  }

  fsp_err_t err = reg_read(OB1203_REG_STATUS0, p_status0, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  return reg_read(OB1203_REG_STATUS1, p_status1, 1);
}

/* ==================== High level control ==================== */

/* Initialization:
 *  - Open I2C if needed
 *  - Delay for power up
 *  - Issue software reset
 *  - Read part ID and status (debug)
 */
fsp_err_t ob1203_init(void) {
  static uint8_t opened = 0;
  fsp_err_t err;
  char msg[64];

  /* Open I2C bus for OB1203 (only once) */
  if (!opened) {
    err = RM_COMMS_I2C_Open(&g_biomet_comms_i2c_ctrl, &g_biomet_comms_i2c_cfg);
    if (FSP_SUCCESS != err) {
      uart_print("[OB1203] I2C open failed\r\n");
      return err;
    }

    opened = 1;
    uart_print("[OB1203] I2C opened\r\n");
  }

  /* Wait for device power-up.
   * OB1203 in this design has NO reset pin,
   * so we only wait and then use software reset. */
  vTaskDelay(pdMS_TO_TICKS(100));

  /* Software reset via control register */
  uart_print("[OB1203] Performing soft reset...\r\n");
  err = ob1203_soft_reset();
  if (FSP_SUCCESS != err) {
    uart_print("[OB1203] Soft reset failed - writing known safe defaults\r\n");

    /* Fallback: disable all blocks first */
    uint8_t val = 0x00;
    (void)reg_write(OB1203_REG_MAIN_CTRL_0, &val, 1);
    (void)reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);

    vTaskDelay(pdMS_TO_TICKS(50));
  } else {
    vTaskDelay(pdMS_TO_TICKS(50));
  }

  /* Read part ID for debug */
  uint8_t part_id = 0;
  err = ob1203_read_part_id(&part_id);

  snprintf(msg, sizeof(msg), "[OB1203] Part ID: 0x%02X (err=%d)\r\n", part_id,
           err);
  uart_print(msg);

  /* Read status (optional) */
  uint8_t st0 = 0;
  uint8_t st1 = 0;
  (void)ob1203_read_status(&st0, &st1);
  snprintf(msg, sizeof(msg), "[OB1203] Status: 0x%02X 0x%02X\r\n", st0, st1);
  uart_print(msg);
  if (!g_ob1203_hr_initialized) {
    ob1203_hr_init(&g_ob1203_hr,
                   100.0f); 
    g_ob1203_hr_initialized = 1U;
    uart_print("[OB1203] HR estimator initialized (fs=100 Hz)\r\n");
  }
  uart_print("[OB1203] Init complete\r\n");

  return FSP_SUCCESS;
}

/* Configure LED currents, gain, averaging, pulse width, sample rate and FIFO */
fsp_err_t ob1203_configure(ob1203_config_t const *p_config) {
  if (!p_config) {
    return FSP_ERR_ASSERTION;
  }

  fsp_err_t err;
  uint8_t val;
  uint8_t buf[2];

  uart_print("[OB1203] Configuring...\r\n");

  /* 1. Disable digital trim (use default) */
  val = 0x00;
  err = reg_write(OB1203_REG_DIG_LED1_TRIM, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  err = reg_write(OB1203_REG_DIG_LED2_TRIM, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 2. Set IR LED current (ILED1) */
  uint16_t ir_curr = (uint16_t)(p_config->ir_led_current & 0x01FFu);
  buf[0] = (uint8_t)(ir_curr & 0xFFu);
  buf[1] = (uint8_t)((ir_curr >> 8) & 0x01u);
  err = reg_write(OB1203_REG_PPG_IR_LED_0, buf, 2);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 3. Set RED LED current (ILED2) */
  uint16_t red_curr = (uint16_t)(p_config->red_led_current & 0x01FFu);
  buf[0] = (uint8_t)(red_curr & 0xFFu);
  buf[1] = (uint8_t)((red_curr >> 8) & 0x01u);
  err = reg_write(OB1203_REG_PPG_R_LED_0, buf, 2);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 4. Gain configuration (fixed value compatible with original project) */
  val = 0x09u;
  err = reg_write(OB1203_REG_PPG_PS_GAIN, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 5. Averaging configuration: encoded as N-1 (0..31) */
  if ((p_config->averaging > 0u) && (p_config->averaging <= 32u)) {
    val = (uint8_t)(p_config->averaging - 1u);
  } else {
    /* Default to 16x averaging if out of range */
    val = 0x0Fu;
  }

  err = reg_write(OB1203_REG_PPG_AVG, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 6. Pulse width and sample rate:
   *    Example: 130us pulse, 100 Hz sample rate. Adjust if needed. */
  val = 0x42u;
  err = reg_write(OB1203_REG_PPG_PWIDTH_RATE, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 7. FIFO configuration:
   *    PPG2 mode (IR+RED), FIFO rollover enabled, etc. */
  val = 0x70u;
  err = reg_write(OB1203_REG_FIFO_CFG, &val, 1);
  if (FSP_SUCCESS != err) {
    return err;
  }

  /* 8. Reset FIFO pointers */
  val = 0x00u;
  (void)reg_write(OB1203_REG_FIFO_WR_PTR, &val, 1);
  (void)reg_write(OB1203_REG_FIFO_RD_PTR, &val, 1);

  uart_print("[OB1203] Configured\r\n");
  return FSP_SUCCESS;
}

/* Enable PPG2 measurement (SpO2 / HR) via MAIN_CTRL_1 register */
fsp_err_t ob1203_start_measurement(void) {
  /* MAIN_CTRL_1 (0x16):
   * bit[3]   = SAI_PS      -> 0 (no sleep-after-interrupt for PS)
   * bit[2:1] = PPG_PS_MODE -> 10b = PPG2 mode (IR + RED interleaved)
   * bit[0]   = PPG_PS_EN   -> 1 = enable PPG/PS block
   *
   * => 0b0000 0101 = 0x05
   */
  uint8_t val = 0x05;
  fsp_err_t err = reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);

  if (FSP_SUCCESS == err) {
    uart_print("[OB1203] PPG2 enabled (MAIN_CTRL_1=0x05)\r\n");
  } else {
    uart_print("[OB1203] Failed to enable PPG2\r\n");
  }

  return err;
}

/* Disable PPG2 measurement */
fsp_err_t ob1203_stop_measurement(void) {
  uint8_t val = 0x00u;

  return reg_write(OB1203_REG_MAIN_CTRL_1, &val, 1);
}

/* ==================== FIFO / data path ==================== */

/* Decode one 18-bit PPG sample from 3 bytes in FIFO_DATA
 * Layout from datasheet:
 *  1st byte: LSB
 *  2nd byte: middle
 *  3rd byte: bits[1:0] = MSB (bits[17:16] of result)
 */
static uint32_t ob1203_decode_sample(const uint8_t *p_bytes) {
  uint32_t lsb = p_bytes[0];
  uint32_t mid = p_bytes[1];
  uint32_t msb2 = (uint32_t)(p_bytes[2] & 0x03u); /* only bits[1:0] */

  return (lsb | (mid << 8) | (msb2 << 16));
}

fsp_err_t ob1203_read_fifo(ob1203_data_t *p_out, uint8_t *p_samples_available)
{
  if ((NULL == p_out) || (NULL == p_samples_available))
  {
    return FSP_ERR_ASSERTION;
  }

  fsp_err_t err;
  uint8_t   wr_ptr;
  uint8_t   rd_ptr;

  /* Read FIFO write/read pointers */
  err = reg_read(OB1203_REG_FIFO_WR_PTR, &wr_ptr, 1);
  if (FSP_SUCCESS != err)
  {
    return err;
  }

  err = reg_read(OB1203_REG_FIFO_RD_PTR, &rd_ptr, 1);
  if (FSP_SUCCESS != err)
  {
    return err;
  }

  /* 5 bits, range 0..31 */
  wr_ptr &= 0x1Fu;
  rd_ptr &= 0x1Fu;

  /* Number of words currently in FIFO (circular) */
  uint8_t words = (wr_ptr >= rd_ptr)
          ? (uint8_t) (wr_ptr - rd_ptr)
          : (uint8_t) (32u + wr_ptr - rd_ptr);

  /* PPG2 mode: each pair (IR, RED) = 2 words = 6 bytes */
  uint8_t pairs = (uint8_t) (words / 2u);
  *p_samples_available = pairs;

  if (0u == pairs)
  {
    /* No new samples – not an error */
    memset(p_out, 0, sizeof(*p_out));
    p_out->valid           = 0u;
    p_out->heart_rate_bpm  = 0.0f;
    p_out->spo2_percent    = 0.0f;
    return FSP_SUCCESS;
  }

  uint8_t  fifo_data[6];
  uint32_t ir_raw_last  = 0;
  uint32_t red_raw_last = 0;

  /* Read ALL IR+RED pairs from FIFO sequentially */
  for (uint8_t i = 0; i < pairs; i++)
  {
    err = reg_read(OB1203_REG_FIFO_DATA, fifo_data, sizeof(fifo_data));
    if (FSP_SUCCESS != err)
    {
      return err;
    }

    /* 3 bytes IR + 3 bytes RED */
    uint32_t ir_raw  = ob1203_decode_sample(&fifo_data[0]);
    uint32_t red_raw = ob1203_decode_sample(&fifo_data[3]);

    ir_raw_last  = ir_raw;
    red_raw_last = red_raw;

    /* ---- Update HR estimator with IR channel ---- */
    if (g_ob1203_hr_initialized)
    {
      (void) ob1203_hr_update(&g_ob1203_hr, ir_raw);
    }

    /* ---- Update SpO2 state (AC/DC) with both IR & RED ---- */
    if (!g_spo2_initialized)
    {
      g_spo2_ir_dc        = (float) ir_raw;
      g_spo2_red_dc       = (float) red_raw;
      g_spo2_R_filtered   = 0.0f;
      g_spo2_initialized  = 1U;
    }

    /* Very slow DC filter to obtain baseline */
    const float alpha_dc = 0.99f;
    g_spo2_ir_dc  = alpha_dc * g_spo2_ir_dc  + (1.0f - alpha_dc) * (float) ir_raw;
    g_spo2_red_dc = alpha_dc * g_spo2_red_dc + (1.0f - alpha_dc) * (float) red_raw;

    float ir_ac  = (float) ir_raw  - g_spo2_ir_dc;
    float red_ac = (float) red_raw - g_spo2_red_dc;

    /* Skip if signal is too small (no finger or noise) */
    const float min_dc = 1000.0f;
    const float min_ac = 1.0f;

    if ((g_spo2_ir_dc > min_dc) && (g_spo2_red_dc > min_dc) &&
      (fabsf(ir_ac) > min_ac) && (fabsf(red_ac) > min_ac))
    {
      float num = red_ac / g_spo2_red_dc;
      float den = ir_ac  / g_spo2_ir_dc;

      if (fabsf(den) > 1e-6f)
      {
        float R_sample = num / den;

        /* Low-pass filter R to reduce jitter */
        const float alpha_R = 0.9f;
        g_spo2_R_filtered = alpha_R * g_spo2_R_filtered +
                  (1.0f - alpha_R) * R_sample;
      }
    }
  }

  /* Return last (most recent) raw samples for debugging */
  p_out->ir_raw  = ir_raw_last;
  p_out->red_raw = red_raw_last;
  p_out->valid   = 1u;

  /* ---- Heart Rate output ---- */
  if (g_ob1203_hr_initialized && g_ob1203_hr.has_bpm)
  {
    p_out->heart_rate_bpm = g_ob1203_hr.bpm;
  }
  else
  {
    p_out->heart_rate_bpm = 0.0f;
  }

  /* ---- SpO2 output (demo, non-medical) ----
   * Using approximation: SpO2 ≈ 110 – 25 * R
   * where R = (ACred/DCred) / (ACir/DCir), taken from g_spo2_R_filtered.
   */
  if (g_spo2_initialized)
  {
    float R    = fabsf(g_spo2_R_filtered);
    float spo2 = 110.0f - 25.0f * R;

    if (spo2 < 0.0f)
    {
      spo2 = 0.0f;
    }
    if (spo2 > 100.0f)
    {
      spo2 = 100.0f;
    }

    p_out->spo2_percent = spo2;
  }
  else
  {
    p_out->spo2_percent = 0.0f;
  }

  return FSP_SUCCESS;
}


/* High-level read: just call FIFO reader and ignore sample count */
fsp_err_t ob1203_read(ob1203_data_t *p_out) {
  uint8_t samples = 0u;
  return ob1203_read_fifo(p_out, &samples);
}

/* ==================== I2C callback ==================== */

/* Communication callback for OB1203 Comms middleware */
void biomet_comms_i2c_callback(rm_comms_callback_args_t *p_args) {
  if (NULL == p_args) {
    return;
  }

  g_i2c_evt = p_args->event;
  g_i2c_done = 1u;
}
